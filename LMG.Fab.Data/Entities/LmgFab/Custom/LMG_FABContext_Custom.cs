using LMG.Fab.Data.Entities.Reflmg;
using LMG.FAB.Util;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace LMG.Fab.Data.Entities.LmgFab
{
    public partial class LMG_FABContext : DbContext
    {
        private readonly IUserService _userService;
        private readonly ReflmgContext _refContext;

        //public LMG_FABContext() : base()
        //{
        //}

        public LMG_FABContext(DbContextOptions<LMG_FABContext> options, IUserService userService, ReflmgContext context) : base(options)
        {
            _userService = userService;
            _refContext = context;
        }



        public virtual DbSet<VwLot> VwLot { get; set; }


        /** le contenu doit etre ajouter à LMG_FABContext.OnModelCreating pour ajouter la definition des vues qui ne sont pas generé par EF
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {

            modelBuilder.Entity<VwLot>(entity =>
            {
                entity.HasKey(e => e.PkLot);
                entity.ToTable("vw_lot");
                entity.Property(e => e.PkLot).HasColumnName("pk_lot");
                entity.Property(e => e.FkOffices).HasColumnName("fk_offices");
                entity.Property(e => e.FkParamDetailProc).HasColumnName("fk_paramDetail_Proc");
            });


        }
        **/
        public override int SaveChanges(bool acceptAllChangesOnSuccess)
        {
            var auditEntries = OnBeforeSaveChanges();
            var result = base.SaveChanges(acceptAllChangesOnSuccess);
            OnAfterSaveChanges(auditEntries);
            return result;
        }

        private List<AuditEntry> OnBeforeSaveChanges()
        {
            // ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            foreach (var entry in ChangeTracker.Entries().ToList())
            {
                if (entry.Entity is Audit || entry.Entity is AuditDetail || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var auditEntry = new AuditEntry(entry);
                auditEntry.TableName = entry.Metadata.Relational().TableName?.ToLower();
                auditEntry.OperationType = entry.State.ToString();
                auditEntry.RecordName = entry.Entity?.ToString();

                auditEntries.Add(auditEntry);

                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State)
                    {
                        case EntityState.Added:

                            if (property.Metadata.IsForeignKey())
                            {
                                Type mytype = entry.Reference(propertyName + "Navigation").Metadata?.ClrType;
                                if (property?.CurrentValue == null)
                                {
                                    auditEntry.NewValues[propertyName] = null;
                                }
                                else
                                {
                                    var currentValue = this.Find(mytype, new object[] { property?.CurrentValue })?.ToString();
                                    auditEntry.NewValues[propertyName] = currentValue;
                                } 
                            }
                            else
                            {
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;

                        case EntityState.Deleted:
                            auditEntry.OldValues[propertyName] = entry.GetDatabaseValues().GetValue<object>(propertyName);
                            break;

                        case EntityState.Modified:
                            if (property.IsModified)
                            {
                                var oldValue = entry.GetDatabaseValues().GetValue<object>(propertyName);
                                if (oldValue?.ToString() != property.CurrentValue?.ToString())
                                {
                                    if (property.Metadata.IsForeignKey())
                                    {
                                        Type mytype = entry.Reference(propertyName + "Navigation").Metadata?.ClrType;
                                        if (mytype != null)
                                        {
                                            var oldValueLabel = this.Find(mytype, new object[] { oldValue })?.ToString();
                                            var newValueLabel = this.Find(mytype, new object[] { property.CurrentValue })?.ToString();
                                            auditEntry.OldValues[propertyName] = oldValueLabel;
                                            auditEntry.NewValues[propertyName] = newValueLabel;
                                        }
                                    }
                                    else
                                    {
                                        auditEntry.OldValues[propertyName] = oldValue;
                                        auditEntry.NewValues[propertyName] = property.CurrentValue;
                                    }
                                }
                            }
                            break;
                    }
                }
            }

            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries.Where(p => !p.HasTemporaryProperties && (p.OldValues?.Count > 0 || p.NewValues?.Count > 0)))
            {
                Audit.Add(auditEntry.ToAudit(_userService, _refContext));
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return auditEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }

        private void OnAfterSaveChanges(List<AuditEntry> auditEntries)
        {
            if (auditEntries == null || auditEntries.Count == 0)
                return; //Task.CompletedTask;


            foreach (var auditEntry in auditEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                Audit.Add(auditEntry.ToAudit(_userService, _refContext));
            }
            SaveChanges();
            //return SaveChangesAsync();
        }

    }
}
